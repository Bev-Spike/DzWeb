定时器的使用

本项目使用最小堆

# 最小堆、红黑树

时间复杂度o(logn),适用于单线程访问，利用epollwait的超时机制，计算最近事件的发生时间。

最小堆需要设计三个类

事件类，里面有事件的到期时间和要执行的回调函数还有事件在最小堆的位置

为了更新事件在最小堆的位置，不可避免地要在最小堆元素进行上浮或下沉的时候更新事件对象，事件对象和最小堆是强耦合的。

-+做成模板类还是算了吧



用最小堆实现的 定时器类，封装定时器的操作，底层容器是STL的vector，用来做事件的容器



定时器工作流程

使用信号每过几秒触发一次中断

中断处理函数通过pipe提醒主线程处理定时器，并重新设置定时信号

定时器自检，检查有没有事件超时的，如果有超时事件，调用事件的回调函数，将连接关闭



怎么创建定时任务？

每个http对象对应一个心跳定时器，epollwait返回的时候会有对应的连接socket。因此http对象内应该含有Event对象，以方便更新定时器状态。

当监听socket获得连接socket时，为该socket对应的http请求对象注册一个Event和回调函数，当事件到的时候，Event调用回调函数，关闭连接

当epollwait返回可写或者可读事件时，可以获得当前事件的socket，修改http对象的Event成员。

怎么感觉对象间的关系这么复杂。。。

# 时间轮

时间复杂度o（1），锁的粒度小，适用于多线程共享定时器的情况

缺点：空间换时间，会出现很多没有使用的内存空间；使用sleep固定时长推进时间指针，会导致频繁唤醒时间轮线程访问时间轮，且有空推进的情况，浪费了CPU资源